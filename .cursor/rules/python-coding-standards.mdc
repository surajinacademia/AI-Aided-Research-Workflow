---
description: Python coding standards for scientific computing and data analysis
globs: "**/*.py"
alwaysApply: true
---

# Python Coding Standards

## Core Principles

- **Style**: Follow PEP 8
- **Execution**: Keep silent - minimize print statements
- **Performance**: Use vectorized operations (numpy/pandas) over loops
- **Functions**: Analysis returns data only; plots accept `ax` argument
- **Simplicity**: Write inline code for one-off logic; functions for reuse


## Jupyter Notebooks

**⚠️ CRITICAL: Edit `.py` files only, NOT `.ipynb`**

```python
# %% [markdown]
# # Analysis Title

# %%
# Code cells use # %%
data = pd.read_csv('data.csv')

# %%
# Maintain 5-line spacing between cells
result = analyze(data)
```

Notebooks sync automatically via jupytext.

## Analysis vs Plotting

**NEVER create plots inside analysis functions:**

```python
# ❌ BAD: Analysis creates plot
def run_simulation():
    history = compute_dynamics()
    plt.plot(history)  # DON'T DO THIS
    return history

# ✅ GOOD: Analysis returns data
def run_simulation():
    """Compute dynamics and return history."""
    return compute_dynamics()

# Plot in separate cell
history = run_simulation()
fig, ax = plt.subplots()
ax.plot(history)
plt.show()
```

## Plot Functions

**All plot functions MUST accept axes:**

```python
# ❌ BAD: Creates own figure
def plot_data(data):
    fig, ax = plt.subplots()
    ax.plot(data)
    plt.savefig('plot.png')

# ✅ GOOD: Accepts axes argument
def plot_data(data, ax):
    """Plot data on provided axes."""
    ax.plot(data)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    return ax

# Caller controls figure
fig, ax = plt.subplots(figsize=(8, 6))
plot_data(data, ax)
plt.savefig('plot.svg')
plt.show()
```
 
## Plotting Configuration

**Standard setup:**

```python
import matplotlib.pyplot as plt
import minimalist

minimalist.use_style("science")
plt.rcParams.update({'figure.facecolor': 'none', 'axes.facecolor': 'none'})

# Publication figure widths
text_width = 510/72.27  # LaTeX text width in inches
```

**Standards:**

- Use matplotlib only (no seaborn)
- Save as SVG for vector graphics
- Save in `figures/` folder
- Use minimalist "science" style

## Code Style

**Inline logic for one-off operations:**

```python
# ❌ BAD: Over-abstracted
def normalize(img):
    return (img - img.min()) / (img.max() - img.min())

for q in quadrants:
    result = normalize(q)

# ✅ GOOD: Inline for one-off
for q in quadrants:
    result = (q - q.min()) / (q.max() - q.min())
```

**Silent execution with inline comments:**

```python
# ❌ BAD: Noisy output
print("Processing...")
for i, f in enumerate(files):
    print(f"File {i+1}/{len(files)}")
    process(f)

# ✅ GOOD: Silent with comments
for f in files:
    # Normalize → filter → threshold
    process(f)
```

## Docstrings

**Simple format with Parameters and Returns:**

```python
def analyze_data(df, threshold=0.5):
    """
    Analyze dataframe and compute metrics.
    
    Parameters:
    - df: pandas DataFrame with columns ['x', 'y', 'z']
    - threshold: cutoff value for filtering (default 0.5)
    
    Returns:
    - dict with keys 'mean', 'std', 'count'
    """
    filtered = df[df['x'] > threshold]
    return {
        'mean': filtered['y'].mean(),
        'std': filtered['y'].std(),
        'count': len(filtered)
    }
```

## Data Analysis

**Pandas best practices:**

```python
# Use vectorized operations
df['result'] = df['x'] * df['y']  # Not: df.apply(lambda row: row['x'] * row['y'])

# Method chaining for readability
result = (df
    .query('value > 0')
    .groupby('category')
    .agg({'value': ['mean', 'std']})
    .reset_index()
)

# Save as CSV
result.to_csv('output.csv', index=False)
```

## Quick Checklist

Before committing:

- [ ] Analysis functions return data (no plots inside)
- [ ] Plot functions accept `ax` argument
- [ ] Jupyter: edited `.py` not `.ipynb`
- [ ] Silent execution (minimal prints)
- [ ] Docstrings with Parameters/Returns
- [ ] Inline logic for one-off operations
- [ ] File order: imports → config → functions → execution
